#!/bin/bash

CW_DATADIR="${XDG_DATA_HOME:-$HOME/.local/share}/clockwerk"
DBFILE="${CW_DATADIR}/clockwerk.db"
LOCKFILE="${CW_DATADIR}/clockwerk.lock"

usage() {
  cat << EOF
 clockwerk <action> [arguments]

 actions: job
          category
          report

 arguments: job start <category> [comment]
                stop
                delete <jobid>

            category add <name> [description]
                     edit <name> <newname> [description]
                     delete <name>

            report [-c category] [-f from] [-t to]

EOF

  exit 0
}

debug() {
  local mesg=$1; shift
  printf "debug: %s\n" "$mesg" >&2
}

die() {
  local mesg=$1; shift
  printf "error: %s\n" "$mesg" >&2
}

warn() {
  local mesg=$1; shift
  printf "warn: %s\n" "$mesg" >&2
}

info() {
  local mesg=$1; shift
  printf ":: %s\n" "$mesg"
}

# returns duration in seconds
# if only 1 arg, end time is assumed to be now
get_duration() {
  local start=$1 end dur
  [[ -n $2 ]] && end=$2 || end=$(date +%s)

  dur=$(( end - start ))

  [[ $dur -lt 0 ]] && return 0 || return $dur
}

date_to_seconds() {
  local seconds=$(date --date="$1" +%s || echo "0")
  return seconds
}

# prints HH MM SS
seconds_to_hms() {
  local seconds=$1 hours=0 minutes=0

  hours=$(( seconds / 3600 ))
  seconds=$(( seconds - hours * 3600 ))

  minutes=$(( seconds / 60 ))
  seconds=$(( seconds - minutes * 60 ))

  echo $hours $minutes $seconds
}

# prints HH MM rounded to nearest minute
seconds_to_hm() {
  local seconds=$1 hours=0 minutes=0

  hours=$(( seconds / 3600 ))
  seconds=$(( seconds - hours * 3600 ))

  minutes=$(( seconds / 60 ))
  seconds=$(( seconds - minutes * 60 ))

  (( seconds >= 30 )) && (( ++minutes ))

  echo $hours $minutes
}


# return 0 on success
# return 1 on failure
initialize_db() {
  local sql="CREATE TABLE job(j_id INTEGER PRIMARY KEY AUTOINCREMENT,
                              j_category TEXT NOT NULL,
                              j_start INTEGER NOT NULL,
                              j_stop INTEGER DEFAULT 0,
                              j_comment NULL,
                              FOREIGN KEY (j_category) REFERENCES category (c_name));
             CREATE TABLE category(c_name TEXT PRIMARY KEY,
                                   c_desc TEXT);"

  exec_query "$sql" || return 1

  return 0
}

exec_query() {
  sqlite3 "$DBFILE" "$@"
}

# returns 0 on success
# returns non-zero on failure
lock_acquire() {
  debug "Acquiring lock"
  [[ -f $LOCKFILE ]] && return 1
  touch "$LOCKFILE" || return 2

  return 0
}

# returns 0 on success
# returns non-zero on failure
lock_release() {
  debug "Releasing lock"
  [[ ! -f $LOCKFILE ]] && return 1
  cat "$LOCKFILE"
  rm "$LOCKFILE"
}

#################################
#       job functions           #
#################################

# return 0 on success
# return 1 on failure to acquire lock
# return 2 on sql error
job_start() {
  # verify category exists
  # do we want to create the category if it doesn't exist?

  lock_acquire || return 1
  local ret=$?
  [[ $ret -eq 1 ]] && die "A job is already running"
  [[ $ret -eq 2 ]] && die "Unable to create lock file"

  local jobstart=$(date +%s) category=$1 comment=$2

  echo "$jobstart|$category|$comment" > "$LOCKFILE"
}

# return 0 on success
# return 1 on error
job_stop() {
  [[ ! -f $LOCKFILE ]] && return 1
  local category jobstart comment jobstop=$(date +%s)

  IFS=$'|' read jobstart category comment < <(lock_release || echo -1)

  [[ $jobstart = "-1" ]] && return 1

  [[ $(get_duration $jobstart $jobstop) -gt 60 ]] && return 2

  local sql="INSERT INTO job(j_category, j_start, j_stop, j_comment)
                      VALUES('$category', '$jobstart', '$jobstop', '$comment');"

  exec_query "$sql" &>/dev/null

  [[ $jobid -eq 0 ]] && return 3
}

job_modify() {
  :
}

#################################
#      category functions       #
#################################

# return 0 on success
# return 1 on category exists
# return 2 on sql error
category_add() {
  local sql="INSERT INTO category(c_name, c_desc) VALUES('$1', '$2');"
  local result=$(exec_query "$sql" 2>&1)

  [[ $result = "Error: column c_name is not unique" ]] && return 1
  [[ $result =~ ^Error:* ]] && return 2

  return 0
}

category_delete() {
  die "Not implemented"
  # check for existance of category, fail if it doesn't exist
  # how to handle removal of a category when jobs use it?
}

category_list() {
  local sql="SELECT DISTINCT j_category FROM job"

  while IFS=$'|' read c_name c_desc; do
    printf "%-20s%-20s\n" "$c_name" "$c_desc"
  done < <(exec_query "$sql")
}


#################################
#      action dispatchers       #
#################################

do_job() {
  local action=$1; shift

  case $action in
    "start")
      [[ -z $1 ]] && die "missing job category"
      job_start "$@"
      ;;
    "stop")
      job_stop
      ;;
    "status")
      job_status
      ;;
    "delete")
      die "Not implemented"
      ;;
    *) usage
      ;;
  esac
}

do_category() {
  local action=$1; shift

  type -p category_$action && category_$action "$@" || usage

}

do_report() {
  local action=$1; shift
  local from to cat

  while getopts "f:t:c:" opt; do
  case "$opt" in
    f) from=$(date --date="$OPTARG" +%s 2>/dev/null) || die "Invalid from date: '$OPTARG'" ;;
    t) to=$(date --date="$OPTARG" +%s 2>/dev/null) || die "Invalid to date: '$OPTARG'" ;;
    c) category_is_valid "$OPTARG" && cat="$OPTARG" || die "Category not found: '$OPTARG'" ;;
    \?) die "Unrecognized option -$OPTARG" ;;
  esac
  done

  # ensure a default date range
  from=${from:-0}
  to=${to:-$(date +%s)}
  cat=${cat:-ALL}

  printf "%5s %-10s %-10s %s\n\n" ID Category Duration Comment
  while IFS=$'|' read id cat start stop comment; do
    printf "%5s %-10s %-10s %s\n" "$id" "$cat" "$(seconds_to_hms $(( stop - start )))" "$comment"
  done < <(exec_query "select * from job")

}

do_status() {
  if [[ -f $LOCKFILE ]]; then
    local jobstart category comment dur
    IFS=$'|' read jobstart category comment < "$LOCKFILE"
    dur=$(( $(date +%s) - jobstart ))
    echo "Job in Progress:"
    echo "Category: $category"
    [[ -n $comment ]] && echo "Comment: $comment"
    printf "Elapsed time: %sh %sm %ss\n" $(seconds_to_hms $dur)
  else
    info "No job currently running"
  fi
}

#############
# main loop #
#############

# sanity checks
[[ ! -d $CW_DATADIR ]] && mkdir -p "$CW_DATADIR"
exec_query 'SELECT * FROM job' &>/dev/null || initialize_db || die "failed to initialize database"

# option parsing
action=$1; shift
type -p do_$action || usage
do_$action "$@"

